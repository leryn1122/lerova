#![feature(prelude_import)]

#[macro_use]
extern crate std;

#[prelude_import]
use std::prelude::rust_2021::*;

pub(crate) mod peg {
  use vsp_ast::ast::AST;
  use vsp_error::VspResult;

  use crate::parser::token::TokenStream;
  use crate::parser::ASTParser;

  pub struct PEGParser {}

  impl ASTParser for PEGParser {
    fn parse(&mut self, tokens: TokenStream) -> VspResult<AST> {
      ::core::panicking::panic("not yet implemented")
    }
  }

  mod peg_parser {
    use vsp_ast::ast::expr::BinaryOp;
    use vsp_ast::ast::expr::Expression;
    use vsp_ast::ast::stmt::*;
    use vsp_support::ptr::make_shared_ptr;

    #[allow(unused_imports)]
    use super::*;
    use crate::token::Token;

    type Input = str;
    type PositionRepr = <Input as ::peg::Parse>::PositionRepr;

    #[allow(unused_parens)]
    struct ParseState<'input> {
      _phantom: ::std::marker::PhantomData<(&'input ())>,
    }

    impl<'input> ParseState<'input> {
      fn new() -> ParseState<'input> {
        ParseState {
          _phantom: ::std::marker::PhantomData,
        }
      }
    }

    fn __parse__<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<()> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let mut __repeat_pos = __pos;
        loop {
          let __pos = __repeat_pos;
          let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
            ::peg::RuleResult::Matched(__next, __ch) => match __ch {
              ' ' | '\n' => ::peg::RuleResult::Matched(__next, ()),
              _ => {
                __err_state.mark_failure(__pos, "[' ' | '\\n']");
                ::peg::RuleResult::Failed
              }
            },
            ::peg::RuleResult::Failed => {
              __err_state.mark_failure(__pos, "[' ' | '\\n']");
              ::peg::RuleResult::Failed
            }
          };
          match __step_res {
            ::peg::RuleResult::Matched(__newpos, __value) => {
              __repeat_pos = __newpos;
            }
            ::peg::RuleResult::Failed => {
              break;
            }
          }
        }
        ::peg::RuleResult::Matched(__repeat_pos, ())
      }
    }

    fn __parse_blank<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<()> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let mut __repeat_pos = __pos;
        let mut __repeat_value = ::alloc::vec::Vec::new();
        loop {
          let __pos = __repeat_pos;
          let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
            ::peg::RuleResult::Matched(__next, __ch) => match __ch {
              ' ' | '\n' => ::peg::RuleResult::Matched(__next, ()),
              _ => {
                __err_state.mark_failure(__pos, "[' ' | '\\n']");
                ::peg::RuleResult::Failed
              }
            },
            ::peg::RuleResult::Failed => {
              __err_state.mark_failure(__pos, "[' ' | '\\n']");
              ::peg::RuleResult::Failed
            }
          };
          match __step_res {
            ::peg::RuleResult::Matched(__newpos, __value) => {
              __repeat_pos = __newpos;
              __repeat_value.push(__value);
            }
            ::peg::RuleResult::Failed => {
              break;
            }
          }
        }
        if __repeat_value.len() >= 1 {
          ::peg::RuleResult::Matched(__repeat_pos, ())
        } else {
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Dot<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ".") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Dot)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\".\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Comma<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ",") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Comma)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\",\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Colon<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Colon)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\":\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_SemiColon<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ";") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::SemiColon)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\";\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Plus<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "+") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Plus)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"+\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Minus<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "-") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Minus)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"-\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Asterisk<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "*") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Asterisk)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"*\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Slash<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "/") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Slash)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"/\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Percentage<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "%") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Percentage)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"%\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_LParenthesis<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "(") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::LParenthesis)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"(\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_RParenthesis<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ")") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::RParenthesis)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\")\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_LBracket<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::LBracket)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"[\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_RBracket<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "]") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::RBracket)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"]\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_LBrace<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "{") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::LBrace)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"{\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_RBrace<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "}") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::RBrace)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"}\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Less<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Less)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"<\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Greater<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ">") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Greater)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\">\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_LessEqual<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<=") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::LessEqual)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"<=\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_GreaterEqual<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ">=") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::GreaterEqual)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\">=\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Equal<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "==") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Equal)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"==\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_NotEqual<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "!=") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::NotEqual)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"!=\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Assigment<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "=") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Assigment)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"=\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_At<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "@") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::At)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"@\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Not<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "!") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Not)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"!\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_And<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&&") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::And)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"&&\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Or<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "||") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Or)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"||\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Xor<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "^") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Xor)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"^\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Question<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "?") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Question)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"?\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_Arrow<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "->") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Arrow)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"->\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_DArrow<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "=>") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::DArrow)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"=>\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_DColon<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "::") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::DColon)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"::\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_SQuote<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "'") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::SQuote)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"'\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_DQuote<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\"") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::DQuote)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"\\\"\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Tk_TQuote<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\"\"\"") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::TQuote)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"\\\"\\\"\\\"\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_As<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "as") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::As)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"as\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Async<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "async") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Async)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"async\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Await<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "await") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Await)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"await\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Break<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "break") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Break)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"break\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Const<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "const") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Const)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"const\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Continue<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "continue") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Continue)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"continue\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Else<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "else") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Else)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"else\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Enum<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "enum") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Enum)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"enum\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_False<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "false") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::False)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"false\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Func<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "func") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Func)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"func\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_For<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "for") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::For)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"for\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_If<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "if") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::If)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"if\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Impl<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "impl") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Impl)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"impl\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Int<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "int") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Int)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"int\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Let<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "let") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Let)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"let\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Loop<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "loop") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Loop)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"loop\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Module<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "module") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Module)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"module\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Public<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "public") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Public)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"public\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Ref<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "ref") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Ref)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"ref\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Return<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "return") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Return)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"return\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Static<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "static") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Static)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"static\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Struct<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "struct") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Struct)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"struct\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Trait<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "trait") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Trait)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"trait\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_True<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "true") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::True)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"true\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Type<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "type") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Type)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"type\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Unsafe<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "unsafe") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Unsafe)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"unsafe\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Use<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "use") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Use)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"use\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Var<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "var") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Var)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"var\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Where<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "where") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Where)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"where\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_While<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "while") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::While)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"while\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Kw_Self<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Token> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "self") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, _) => {
              ::peg::RuleResult::Matched(__pos, (|| Token::Self_)())
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"self\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Lit_Integer_Dec<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<i64> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = {
          let str_start = __pos;
          match {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = ::alloc::vec::Vec::new();
            loop {
              let __pos = __repeat_pos;
              let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                  '0'..='9' => ::peg::RuleResult::Matched(__next, ()),
                  _ => {
                    __err_state.mark_failure(__pos, "['0' ..= '9']");
                    ::peg::RuleResult::Failed
                  }
                },
                ::peg::RuleResult::Failed => {
                  __err_state.mark_failure(__pos, "['0' ..= '9']");
                  ::peg::RuleResult::Failed
                }
              };
              match __step_res {
                ::peg::RuleResult::Matched(__newpos, __value) => {
                  __repeat_pos = __newpos;
                  __repeat_value.push(__value);
                }
                ::peg::RuleResult::Failed => {
                  break;
                }
              }
            }
            if __repeat_value.len() >= 1 {
              ::peg::RuleResult::Matched(__repeat_pos, ())
            } else {
              ::peg::RuleResult::Failed
            }
          } {
            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
              __newpos,
              ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
            ),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, val) => {
            let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
              ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, _) => {
                match (|| {
                  i64::from_str_radix(val, 10)
                    .map_err(|e| "error occurred during parsing integer literal")
                })() {
                  Ok(res) => ::peg::RuleResult::Matched(__pos, res),
                  Err(expected) => {
                    __err_state.mark_failure(__pos, expected);
                    ::peg::RuleResult::Failed
                  }
                }
              }
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Lit_Integer_Oct<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<i64> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "0") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = {
            let str_start = __pos;
            match {
              let mut __repeat_pos = __pos;
              let mut __repeat_value = ::alloc::vec::Vec::new();
              loop {
                let __pos = __repeat_pos;
                let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                  ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                    '0'..='9' => ::peg::RuleResult::Matched(__next, ()),
                    _ => {
                      __err_state.mark_failure(__pos, "['0' ..= '9']");
                      ::peg::RuleResult::Failed
                    }
                  },
                  ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "['0' ..= '9']");
                    ::peg::RuleResult::Failed
                  }
                };
                match __step_res {
                  ::peg::RuleResult::Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                  }
                  ::peg::RuleResult::Failed => {
                    break;
                  }
                }
              }
              if __repeat_value.len() >= 1 {
                ::peg::RuleResult::Matched(__repeat_pos, ())
              } else {
                ::peg::RuleResult::Failed
              }
            } {
              ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                __newpos,
                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
              ),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, val) => {
              let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
                ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
              };
              match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                  match (|| {
                    i64::from_str_radix(val, 8)
                      .map_err(|e| "error occurred during parsing integer literal")
                  })() {
                    Ok(res) => ::peg::RuleResult::Matched(__pos, res),
                    Err(expected) => {
                      __err_state.mark_failure(__pos, expected);
                      ::peg::RuleResult::Failed
                    }
                  }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
              }
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"0\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Lit_Integer_Hex<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<i64> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "0x") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = {
            let str_start = __pos;
            match {
              let mut __repeat_pos = __pos;
              let mut __repeat_value = ::alloc::vec::Vec::new();
              loop {
                let __pos = __repeat_pos;
                let __step_res = {
                  let __choice_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                    ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                      '0'..='9' => ::peg::RuleResult::Matched(__next, ()),
                      _ => {
                        __err_state.mark_failure(__pos, "['0' ..= '9']");
                        ::peg::RuleResult::Failed
                      }
                    },
                    ::peg::RuleResult::Failed => {
                      __err_state.mark_failure(__pos, "['0' ..= '9']");
                      ::peg::RuleResult::Failed
                    }
                  };
                  match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                      ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                      let __choice_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                        ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                          'a'..='f' => ::peg::RuleResult::Matched(__next, ()),
                          _ => {
                            __err_state.mark_failure(__pos, "['a' ..= 'f']");
                            ::peg::RuleResult::Failed
                          }
                        },
                        ::peg::RuleResult::Failed => {
                          __err_state.mark_failure(__pos, "['a' ..= 'f']");
                          ::peg::RuleResult::Failed
                        }
                      };
                      match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                          ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                          match ::peg::ParseElem::parse_elem(__input, __pos) {
                            ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                              'A'..='F' => ::peg::RuleResult::Matched(__next, ()),
                              _ => {
                                __err_state.mark_failure(__pos, "['A' ..= 'F']");
                                ::peg::RuleResult::Failed
                              }
                            },
                            ::peg::RuleResult::Failed => {
                              __err_state.mark_failure(__pos, "['A' ..= 'F']");
                              ::peg::RuleResult::Failed
                            }
                          }
                        }
                      }
                    }
                  }
                };
                match __step_res {
                  ::peg::RuleResult::Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                  }
                  ::peg::RuleResult::Failed => {
                    break;
                  }
                }
              }
              if __repeat_value.len() >= 1 {
                ::peg::RuleResult::Matched(__repeat_pos, ())
              } else {
                ::peg::RuleResult::Failed
              }
            } {
              ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                __newpos,
                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
              ),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, val) => {
              let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
                ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
              };
              match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                  match (|| {
                    i64::from_str_radix(val, 16)
                      .map_err(|e| "error occurred during parsing integer literal")
                  })() {
                    Ok(res) => ::peg::RuleResult::Matched(__pos, res),
                    Err(expected) => {
                      __err_state.mark_failure(__pos, expected);
                      ::peg::RuleResult::Failed
                    }
                  }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
              }
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"0x\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Lit_Integer<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<i64> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = {
          let __choice_res = __parse_Lit_Integer_Dec(__input, __state, __err_state, __pos);
          match __choice_res {
            ::peg::RuleResult::Matched(__pos, __value) => {
              ::peg::RuleResult::Matched(__pos, __value)
            }
            ::peg::RuleResult::Failed => {
              let __choice_res = __parse_Lit_Integer_Oct(__input, __state, __err_state, __pos);
              match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                  ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                  __parse_Lit_Integer_Hex(__input, __state, __err_state, __pos)
                }
              }
            }
          }
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, val) => {
            let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
              ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(__pos, (|| val)()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Lit_Bool<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<bool> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = {
          let str_start = __pos;
          match {
            let __choice_res =
              match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "true") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                  ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => {
                  __err_state.mark_failure(__pos, "\"true\"");
                  ::peg::RuleResult::Failed
                }
              };
            match __choice_res {
              ::peg::RuleResult::Matched(__pos, __value) => {
                ::peg::RuleResult::Matched(__pos, __value)
              }
              ::peg::RuleResult::Failed => {
                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "false") {
                  ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                  }
                  ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"false\"");
                    ::peg::RuleResult::Failed
                  }
                }
              }
            }
          } {
            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
              __newpos,
              ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
            ),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, val) => {
            let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
              ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, _) => {
                ::peg::RuleResult::Matched(__pos, (|| val == "true")())
              }
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Lit_String<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<&'input str> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\"") {
        ::peg::RuleResult::Matched(__pos, __val) => {
          let __seq_res = {
            let str_start = __pos;
            match {
              let mut __repeat_pos = __pos;
              loop {
                let __pos = __repeat_pos;
                let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                  ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                    '\n' | '\"' => {
                      __err_state.mark_failure(__pos, "[^ '\\n' | '\\\"']");
                      ::peg::RuleResult::Failed
                    }
                    _ => ::peg::RuleResult::Matched(__next, ()),
                  },
                  ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "[^ '\\n' | '\\\"']");
                    ::peg::RuleResult::Failed
                  }
                };
                match __step_res {
                  ::peg::RuleResult::Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                  }
                  ::peg::RuleResult::Failed => {
                    break;
                  }
                }
              }
              ::peg::RuleResult::Matched(__repeat_pos, ())
            } {
              ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                __newpos,
                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
              ),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          };
          match __seq_res {
            ::peg::RuleResult::Matched(__pos, val) => {
              match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\"") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                  let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                  };
                  match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                      ::peg::RuleResult::Matched(__pos, (|| val)())
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                  }
                }
                ::peg::RuleResult::Failed => {
                  __err_state.mark_failure(__pos, "\"\\\"\"");
                  ::peg::RuleResult::Failed
                }
              }
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        }
        ::peg::RuleResult::Failed => {
          __err_state.mark_failure(__pos, "\"\\\"\"");
          ::peg::RuleResult::Failed
        }
      }
    }

    fn __parse_Lit_Float<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<f64> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = {
          let str_start = __pos;
          match {
            let __seq_res = {
              let mut __repeat_pos = __pos;
              let mut __repeat_value = ::alloc::vec::Vec::new();
              loop {
                let __pos = __repeat_pos;
                let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                  ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                    '0'..='9' => ::peg::RuleResult::Matched(__next, ()),
                    _ => {
                      __err_state.mark_failure(__pos, "['0' ..= '9']");
                      ::peg::RuleResult::Failed
                    }
                  },
                  ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "['0' ..= '9']");
                    ::peg::RuleResult::Failed
                  }
                };
                match __step_res {
                  ::peg::RuleResult::Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                  }
                  ::peg::RuleResult::Failed => {
                    break;
                  }
                }
              }
              if __repeat_value.len() >= 1 {
                ::peg::RuleResult::Matched(__repeat_pos, ())
              } else {
                ::peg::RuleResult::Failed
              }
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, _) => {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ".")
                {
                  ::peg::RuleResult::Matched(__pos, __val) => {
                    let __seq_res = {
                      let mut __repeat_pos = __pos;
                      loop {
                        let __pos = __repeat_pos;
                        let __step_res = match ::peg::ParseElem::parse_elem(__input, __pos) {
                          ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                            '0'..='9' => ::peg::RuleResult::Matched(__next, ()),
                            _ => {
                              __err_state.mark_failure(__pos, "['0' ..= '9']");
                              ::peg::RuleResult::Failed
                            }
                          },
                          ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "['0' ..= '9']");
                            ::peg::RuleResult::Failed
                          }
                        };
                        match __step_res {
                          ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                          }
                          ::peg::RuleResult::Failed => {
                            break;
                          }
                        }
                      }
                      ::peg::RuleResult::Matched(__repeat_pos, ())
                    };
                    match __seq_res {
                      ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(__pos, ()),
                      ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                  }
                  ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\".\"");
                    ::peg::RuleResult::Failed
                  }
                };
                match __seq_res {
                  ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(__pos, ()),
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
              }
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          } {
            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
              __newpos,
              ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
            ),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, val) => {
            let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
              ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(
                __pos,
                (|| {
                  use std::str::FromStr;
                  f64::from_str(val).unwrap()
                })(),
              ),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Bin_Op<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<BinaryOp> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = {
          let str_start = __pos;
          match {
            let __choice_res = match __parse_Tk_Plus(__input, __state, __err_state, __pos) {
              ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __choice_res {
              ::peg::RuleResult::Matched(__pos, __value) => {
                ::peg::RuleResult::Matched(__pos, __value)
              }
              ::peg::RuleResult::Failed => {
                let __choice_res = match __parse_Tk_Minus(__input, __state, __err_state, __pos) {
                  ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __choice_res {
                  ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                  }
                  ::peg::RuleResult::Failed => {
                    let __choice_res =
                      match __parse_Tk_Asterisk(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                      };
                    match __choice_res {
                      ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                      }
                      ::peg::RuleResult::Failed => {
                        match __parse_Tk_Slash(__input, __state, __err_state, __pos) {
                          ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                      }
                    }
                  }
                }
              }
            }
          } {
            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
              __newpos,
              ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
            ),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
          }
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, val) => {
            let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
              ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(
                __pos,
                (|| {
                  let val1 = val.trim();
                  match val1 {
                    "+" => BinaryOp::Add,
                    "-" => BinaryOp::Subtract,
                    "/" => BinaryOp::Multiply,
                    "*" => BinaryOp::Division,
                    _ => ::core::panicking::panic("internal error: entered unreachable code"),
                  }
                })(),
              ),
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Expr<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Expression> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        fn __infix_parse<T, S>(
          state: &mut S,
          err_state: &mut ::peg::error::ErrorState,
          min_prec: i32,
          lpos: usize,
          prefix_atom: &Fn(
            usize,
            &mut S,
            &mut ::peg::error::ErrorState,
            &Fn(usize, i32, &mut S, &mut ::peg::error::ErrorState) -> ::peg::RuleResult<T>,
          ) -> ::peg::RuleResult<T>,
          level_code: &Fn(
            usize,
            usize,
            i32,
            T,
            &mut S,
            &mut ::peg::error::ErrorState,
            &Fn(usize, i32, &mut S, &mut ::peg::error::ErrorState) -> ::peg::RuleResult<T>,
          ) -> (T, ::peg::RuleResult<()>),
        ) -> ::peg::RuleResult<T> {
          let initial = {
            prefix_atom(
              lpos,
              state,
              err_state,
              &(|pos, min_prec, state, err_state| {
                __infix_parse(state, err_state, min_prec, pos, prefix_atom, level_code)
              }),
            )
          };
          if let ::peg::RuleResult::Matched(pos, mut infix_result) = initial {
            let mut repeat_pos = pos;
            loop {
              let (val, res) = level_code(
                repeat_pos,
                lpos,
                min_prec,
                infix_result,
                state,
                err_state,
                &(|pos, min_prec, state, err_state| {
                  __infix_parse(state, err_state, min_prec, pos, prefix_atom, level_code)
                }),
              );
              infix_result = val;
              if let ::peg::RuleResult::Matched(pos, ()) = res {
                repeat_pos = pos;
                continue;
              }
              break;
            }
            ::peg::RuleResult::Matched(repeat_pos, infix_result)
          } else {
            ::peg::RuleResult::Failed
          }
        }
        __infix_parse(
          __state,
          __err_state,
          0,
          __pos,
          &(|__pos, __state, __err_state, __recurse| {
            let __lpos = __pos;
            if let ::peg::RuleResult::Matched(__pos, __v) = {
              let __seq_res = __parse_Lit_String(__input, __state, __err_state, __pos);
              match __seq_res {
                ::peg::RuleResult::Matched(__pos, val) => ::peg::RuleResult::Matched(
                  __pos,
                  (|| Expression::LiteralString(String::from(val)))(),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
              }
            } {
              return ::peg::RuleResult::Matched(__pos, __v);
            }
            if let ::peg::RuleResult::Matched(__pos, __v) = {
              let __seq_res = __parse_Lit_Integer(__input, __state, __err_state, __pos);
              match __seq_res {
                ::peg::RuleResult::Matched(__pos, val) => {
                  ::peg::RuleResult::Matched(__pos, (|| Expression::LiteralInteger(val))())
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
              }
            } {
              return ::peg::RuleResult::Matched(__pos, __v);
            }
            ::peg::RuleResult::Failed
          }),
          &(|__pos, __lpos, __min_prec, mut __infix_result, __state, __err_state, __recurse| {
            if 2i32 >= __min_prec {
              if let ::peg::RuleResult::Matched(__pos, ()) = {
                let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
                  ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __seq_res {
                  ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = __parse_Bin_Op(__input, __state, __err_state, __pos);
                    match __seq_res {
                      ::peg::RuleResult::Matched(__pos, op) => {
                        let __seq_res = match __parse__(__input, __state, __err_state, __pos) {
                          ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        };
                        match __seq_res {
                          ::peg::RuleResult::Matched(__pos, _) => {
                            if let ::peg::RuleResult::Matched(__pos, right) =
                              __recurse(__pos, 3i32, __state, __err_state)
                            {
                              let left = __infix_result;
                              __infix_result = (|| {
                                Expression::Binary(
                                  op,
                                  make_shared_ptr(left),
                                  make_shared_ptr(right),
                                )
                              })();
                              ::peg::RuleResult::Matched(__pos, ())
                            } else {
                              ::peg::RuleResult::Failed
                            }
                          }
                          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                      }
                      ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                  }
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
              } {
                return (__infix_result, ::peg::RuleResult::Matched(__pos, ()));
              }
            }
            (__infix_result, ::peg::RuleResult::Failed)
          }),
        )
      }
    }

    fn __parse_NoOp_Stmt<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Statement> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = match __parse_Tk_SemiColon(__input, __state, __err_state, __pos) {
          ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, _) => {
            ::peg::RuleResult::Matched(__pos, (|| Statement::NoOp)())
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Return_Stmt<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Statement> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = match __parse_Kw_Return(__input, __state, __err_state, __pos) {
          ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, _) => {
            let __seq_res = __parse_Expr(__input, __state, __err_state, __pos);
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, expr) => {
                let __seq_res = match __parse_Tk_SemiColon(__input, __state, __err_state, __pos) {
                  ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __seq_res {
                  ::peg::RuleResult::Matched(__pos, _) => {
                    ::peg::RuleResult::Matched(__pos, (|| Statement::Return(Some(expr)))())
                  }
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
              }
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    fn __parse_Stmt<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Statement> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __choice_res = __parse_NoOp_Stmt(__input, __state, __err_state, __pos);
        match __choice_res {
          ::peg::RuleResult::Matched(__pos, __value) => ::peg::RuleResult::Matched(__pos, __value),
          ::peg::RuleResult::Failed => {
            let __choice_res = __parse_Return_Stmt(__input, __state, __err_state, __pos);
            match __choice_res {
              ::peg::RuleResult::Matched(__pos, __value) => {
                ::peg::RuleResult::Matched(__pos, __value)
              }
              ::peg::RuleResult::Failed => __parse_Stmts(__input, __state, __err_state, __pos),
            }
          }
        }
      }
    }

    fn __parse_Stmts<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Statement> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      {
        let __seq_res = match __parse_Tk_LBrace(__input, __state, __err_state, __pos) {
          ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        };
        match __seq_res {
          ::peg::RuleResult::Matched(__pos, _) => {
            let __seq_res = {
              let mut __repeat_pos = __pos;
              let mut __repeat_value = ::alloc::vec::Vec::new();
              loop {
                let __pos = __repeat_pos;
                let __step_res = __parse_Stmt(__input, __state, __err_state, __pos);
                match __step_res {
                  ::peg::RuleResult::Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                  }
                  ::peg::RuleResult::Failed => {
                    break;
                  }
                }
              }
              ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
            };
            match __seq_res {
              ::peg::RuleResult::Matched(__pos, stmts) => {
                let __seq_res = match __parse_Tk_RBrace(__input, __state, __err_state, __pos) {
                  ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __seq_res {
                  ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(
                    __pos,
                    (|| {
                      let stmt = StatementBlock::from(stmts);
                      Statement::Block(Box::new(stmt))
                    })(),
                  ),
                  ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
              }
              ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
          }
          ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
      }
    }

    pub fn src_file<'input>(
      __input: &'input Input,
    ) -> ::std::result::Result<Statement, ::peg::error::ParseError<PositionRepr>> {
      #![allow(non_snake_case, unused)]
      let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
      let mut __state = ParseState::new();
      match __parse_src_file(
        __input,
        &mut __state,
        &mut __err_state,
        ::peg::Parse::start(__input),
      ) {
        ::peg::RuleResult::Matched(__pos, __value) => {
          if ::peg::Parse::is_eof(__input, __pos) {
            return Ok(__value);
          } else {
            __err_state.mark_failure(__pos, "EOF");
          }
        }
        _ => (),
      }
      __state = ParseState::new();
      __err_state.reparse_for_error();
      match __parse_src_file(
        __input,
        &mut __state,
        &mut __err_state,
        ::peg::Parse::start(__input),
      ) {
        ::peg::RuleResult::<Statement>::Matched(__pos, __value) => {
          if ::peg::Parse::is_eof(__input, __pos) {
            {
              ::std::rt::begin_panic(
                "Parser is nondeterministic: succeeded when reparsing for error position",
              );
            };
          } else {
            __err_state.mark_failure(__pos, "EOF");
          }
        }
        _ => (),
      }
      Err(__err_state.into_parse_error(__input))
    }

    fn __parse_src_file<'input>(
      __input: &'input Input,
      __state: &mut ParseState<'input>,
      __err_state: &mut ::peg::error::ErrorState,
      __pos: usize,
    ) -> ::peg::RuleResult<Statement> {
      #![allow(non_snake_case, unused, clippy::redundant_closure_call)]
      __parse_Stmts(__input, __state, __err_state, __pos)
    }
  }
}
